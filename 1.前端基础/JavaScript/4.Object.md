# Object

[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object)

## 1. 定义

MDN文档对Object做出了如下定义：

    Object 是 JavaScript 的一种 数据类型 。它用于存储各种键值集合和更复杂的实体。Objects 可以通过 Object() 构造函数或者使用 对象字面量 的方式创建。

简而言之，Object是JS里唯一一种复杂的数据类型，是无序的键值对（key-value）的集合。例如：

## 2. 其他参数

### 2.1 PropertyDescriptor(descriptor) 属性描述符

```js
interface PropertyDescriptor {
  configurable?: boolean;
  enumerable?: boolean;
  value?: any;
  writable?: boolean;
  get?(): any;
  set?(v: any): void;
}
```
`configurable`

当设置为 false 时，
- 该属性的类型不能在数据属性和访问器属性之间更改，
- 该属性不可被删除，
- 其描述符的其他属性也不能被更改（但是，如果它是一个可写的数据描述符，则 value 可以被更改，writable 可以更改为 false）。

默认值为 false。

`enumerable`

当且仅当该属性在对应对象的属性枚举中出现时，值为 true。默认值为 false。

`value`

与属性相关联的值。可以是任何有效的 JavaScript 值（数字、对象、函数等）。默认值为 undefined。

`writable`

如果与属性相关联的值可以使用赋值运算符更改，则为 true。默认值为 false。

`get`

用作属性 getter 的函数，如果没有 getter 则为 undefined。当访问该属性时，将不带参地调用此函数，并将 this 设置为通过该属性访问的对象（因为可能存在继承关系，这可能不是定义该属性的对象）。返回值将被用作该属性的值。默认值为 undefined。

`set`

用作属性 setter 的函数，如果没有 setter 则为 undefined。当该属性被赋值时，将调用此函数，并带有一个参数（要赋给该属性的值），并将 this 设置为通过该属性分配的对象。默认值为 undefined。

## 3. 方法

`js代码 ./js/4.Object`

### 3.1 Object.create() 创建新对象

Object.create() 方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）

语法
- Object.create(proto)
- Object.create(proto, propertiesObject)

参数
- proto 新创建对象的原型对象。
- propertiesObject （可选）如果该参数被指定且不为 undefined，则该传入对象的自有可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）将为新创建的对象添加指定的属性值和对应的属性描述符。这些属性对应于 Object.defineProperties() 的第二个参数。

返回值
- 一个新对象，带着指定的原型对象及其属性。

```js
const obj = Object.create({ a: 1 }, { b: { value: 2 } }); // obj = {}
// 第一个参数为对象，对象为函数调用之后返回新对象的原型对象，第二个参数为对象本身的实例方法（默认不能修改,不能枚举）
const bool1 = obj.__proto__.a === 1; // true
obj.b = 3; // obj.b: 2

const obj1_1 = Object.create({}, {
  p: {
    value: 2, // 属性值
    writable: true, // 是否可以重写值
    enumerable: true, //是否可枚举
    configurable: true //是否可以修改以上几项配置
  }
})

obj1_1.p = 3; // obj1_1: { p: 3 }
// 注意： enumerable 会影响以下
// for…in  遍历包括对象原型上属性
// Object.keys()   只能遍历自身属性
// JSON.stringify  只能序列化自身属性
```

### 3.2 Object.assign() 复制修改对象

`Object.assign()` 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。

语法
- Object.assign(target, ...sources)

参数
- target 目标对象，接收源对象属性的对象，也是修改后的返回值。
- sources 源对象，包含将被合并的属性。

返回值
- 目标对象

```js
const obj2_1 = { a: 1, b: 2, c: 3 }
const obj2_2 = { b: 11, c: 12, d: 13 }
const assignObj = Object.assign(obj2_1, obj2_2)
// {
//   obj2_1: { a: 1, b: 11, c: 12, d: 13 },
//   obj2_2: { b: 11, c: 12, d: 13 },
//   assignObj: { a: 1, b: 11, c: 12, d: 13 }
// }
```

### 3.3 Object.defineProperty() 定义对象属性

Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。

语法
- Object.defineProperty(obj, prop, descriptor)

参数
- obj 要定义属性的对象。
- prop 要定义或修改的属性的名称或 Symbol 。
- descriptor 要定义或修改的属性描述符。

返回值
- 被传递给函数的对象。

```js
const obj3 = {}
Object.defineProperty(obj3, 'a', {
  value: 11,
  writable: false, // 不可编辑
})
obj3.a = 12; // obj.a: 11
```

### 3.4 Object.defineProperties() 定义多个对象属性

`Object.defineProperties()` 静态方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。

语法
- Object.defineProperties(obj, props)

参数
- obj 要定义属性的对象。
- props 一个对象，其中每个键表示要定义或修改的属性的名称，每个值是描述该属性的对象。在 props 中的每个值必须是且只能是数据描述符或访问器描述符之一；不能同时为两者

返回值
- 被传递给函数的对象。

```js
const obj1 = {};
Object.defineProperties(obj1, {
  a: {
    value: 42,
    writable: true,
  },
  b: {},
});
console.log(obj1.a, obj1.b);
// Expected output: 42 undefined

```

### 3.5 Object.entries() 返回给定对象自身可枚举属性的 [key, value] 数组

`Object.entries()` 静态方法返回一个数组，包含给定对象自有的可枚举字符串键属性的键值对。

语法
- Object.entries(obj)

参数
- obj 一个对象。

返回值
- 一个由给定对象自有的可枚举字符串键属性的键值对组成的数组。每个键值对都是一个包含两个元素的数组：第一个元素是属性的键（始终是字符串），第二个元素是属性值。

#### 3.5.1 基本使用

```js
const obj1 = { foo: 'bar', bar1: 'foo1' }
const arr1 = Object.entries(obj1)

// 类数组对象
const obj2 = { a: 1, b: 2, c: 3, d: 4, e: 5 }
const arr2 = Object.entries(obj1)

// 具有随机键排序的类数组对象
const obj3 = { 100: "a", 2: "b", 7: "c" }
const arr3 = Object.entries(obj3)

const objFc = Object.create({}, {
  getFoo: {
    value() {
      return this.foo
    }
  }
})

objFc.foo = 'objFc-bar'
const arr4 = Object.entries(objFc)

console.info({ arr1, arr2, arr3, arr4 });
// {
//   arr1: [ [ 'foo', 'bar' ], [ 'bar1', 'foo1' ] ],
//   arr2: [ [ 'foo', 'bar' ], [ 'bar1', 'foo1' ] ],
//   arr3: [ [ '2', 'b' ], [ '7', 'c' ], [ '100', 'a' ] ],
//   arr4: [ [ 'foo', 'objFc-bar' ] ]
// }
```

#### 3.5.2 在基本类型中使用

非对象参数会强制转换成对象。只有字符串可以有自己的可枚举属性，所有其他基本类型均返回一个空数组。

```js
// 字符串具有索引作为可枚举的自有属性
console.log(Object.entries("foo")); // [ ['0', 'f'], ['1', 'o'], ['2', 'o'] ]

// 其他基本类型没有自有属性
console.log(Object.entries(100)); // []
```

#### 3.5.3 将 Object 转换成 Map

Map() 构造函数接受一个 entries 可迭代对象。使用 Object.entries，你可以很容易地将 Object 转换成 Map：

```js
const obj = { foo: "bar", baz: 42 };
const map = new Map(Object.entries(obj));
console.log(map); // Map(2) {"foo" => "bar", "baz" => 42}
```

#### 3.5.4 遍历对象

使用数组解构语法，你可以很容易地遍历对象。

```js
// 使用 for...of 循环
const obj = { a: 5, b: 7, c: 9 };
for (const [key, value] of Object.entries(obj)) {
  console.log(`${key} ${value}`); // "a 5", "b 7", "c 9"
}

// 使用数组方法
Object.entries(obj).forEach(([key, value]) => {
  console.log(`${key} ${value}`); // "a 5", "b 7", "c 9"
});
```

### 3.6 Object.freeze() 使一个对象被冻结

Object.freeze() 静态方法可以使一个对象被冻结。冻结对象可以防止扩展，并使现有的属性不可写入和不可配置。被冻结的对象不能再被更改：不能添加新的属性，不能移除现有的属性，不能更改它们的可枚举性、可配置性、可写性或值，对象的原型也不能被重新指定。freeze() 返回与传入的对象相同的对象。

冻结一个对象是 JavaScript 提供的最高完整性级别保护措施。

语法
- Object.freeze(obj)

```js
const obj = {
  prop: 42,
};

Object.freeze(obj);

obj.prop = 33; // Throws an error in strict mode

console.log(obj.prop); // Expected output: 42
```

```js
Object.freeze(new Uint8Array(0)); // 没有元素
// Uint8Array []

Object.freeze(new Uint8Array(1)); // 有元素
// TypeError: Cannot freeze array buffer views with elements

Object.freeze(new DataView(new ArrayBuffer(32))); // 没有元素
// DataView {}

Object.freeze(new Float64Array(new ArrayBuffer(64), 63, 0)); // 没有元素
// Float64Array []

Object.freeze(new Float64Array(new ArrayBuffer(64), 32, 2)); // 有元素
// TypeError: Cannot freeze array buffer views with elements
```

### 3.7 Object.fromEntries() 将键值对列表转换为一个对象

Object.fromEntries() 静态方法将键值对列表转换为一个对象。

Object.fromEntries() 是 Object.entries() 的逆操作，只是 Object.entries() 只返回字符串键属性，而 Object.fromEntries() 还可以创建符号键属性。

语法
- Object.fromEntries(iterable)

参数
- iterable

>一个包含对象列表的可迭代对象，例如 Array 或者 Map。每个对象都要有两个属性：
>
>0
>表示属性键的字符串或者 Symbol。
>
>1
>属性值。
>
>通常，该对象被实现为二元数组，第一个元素是属性键，第二个元素是属性值。

返回值
- 一个新对象，其属性由可迭代对象的条目给定。

#### 1 将 Map 转换成对象
通过 Object.fromEntries，你可以将 Map 转换成 Object：
```js
const map = new Map([
  ['foo', 'bar'],
  [1, 2],
]);
const obj = Object.fromEntries(map)
console.info('--- fromEntries --->', obj);
// { '1': 2, foo: 'bar' }
```
#### 2 将 数组 转换成对象
通过 Object.fromEntries，你可以将 Array 转换成 Object：
```js
const arr = [
  ["0", "a"],
  ["1", "b"],
  ["2", "c"],
];
const obj = Object.fromEntries(arr);
console.log(obj); // { 0: "a", 1: "b", 2: "c" }
```

#### 3 对象转换
通过 Object.fromEntries、其逆操作 Object.entries() 和数组操作方法，你可以像这样转换对象：

```js
const object1 = { a: 1, b: 2, c: 3 };

const object2 = Object.fromEntries(
  Object.entries(object1).map(([key, val]) => [key, val * 2]),
);

console.log(object2);
// { a: 2, b: 4, c: 6 }
```