# 设计模式

## 1.目的

设计模式是为了更好的代码复用、可读、可靠、可维护。

## 2.原则-五大设计原则-SOLID

- S – Single Responsibility Principle 单一职责原则
  - 一个程序只做好一件事
  - 如果功能过于复杂就拆分开，每个部分保持独立
- O – OpenClosed Principle 开放/封闭原则
  - 对扩展开放，对修改封闭
  - 增加需求时，扩展新代码，而非修改已有代码
- L – Liskov Substitution Principle 里氏替换原则
  - 子类能覆盖父类
  - 父类能出现的地方子类就能出现
- I – Interface Segregation Principle 接口隔离原则
  - 保持接口的单一独立
  - 类似单一职责原则，这里更关注接口
- D – Dependency Inversion Principle 依赖倒转原则
  - 面向接口编程，依赖于抽象而不依赖于具体
  - 使用方只关注接口而不关注具体类的实现

## 3.类型

- 创建型
  - 单例模式
  - 工厂模式
  - 抽象工厂模式
  - 原型模式
  - 建造者模式
- 结构型
  - 适配器模式
  - 装饰器模式
  - 代理模式
  - 外观模式
  - 桥接模式
  - 组合模式
  - 享元模式
- 行为型
  - 观察者模式
  - 迭代器模式
  - 策略模式
  - 模板方法模式
  - 职责链模式
  - 命令模式
  - 备忘录模式
  - 状态模式
  - 访问者模式
  - 中介者模式
  - 解释器模式

### 3.1 单例模式 Singleton

专业解释：

单例模式是一种确保在任何情况下一个类仅有一个实例，并提供全局访问点的设计模式。它主要用于控制对全局唯一资源的访问。

通俗理解：

就好比一座城市里只有一座供水站，不论你需要从哪里取水，都只能通过这个供水站来获取，而且全市人民共用的是同一座供水站。

> 优点：

节约系统资源，对于那些需要频繁创建和销毁的对象，单例模式可以提高系统性能。

提供了全局访问点，对象间通信更简单。

> 缺点：

不适用于多线程环境，可能会引起线程安全问题。

单例对象的状态，对于依赖它的对象可能不易处理。

单例模式在系统中引入全局状态，增加了测试的复杂性。

### 3.2 工厂模式 Factory

- 简单工厂模式
- 工厂方法模式
- 抽象工厂模式

> 适用场景

- 如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择
- 将new操作简单封装，遇到new的时候就应该考虑是否用工厂模式；
- 需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性

> 优点

- 创建对象的过程可能很复杂，但我们只需要关心创建结果。
- 构造函数和创建者分离, 符合“开闭原则”
- 一个调用者想创建一个对象，只要知道其名称就可以了。
- 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。

> 缺点

- 添加新产品时，需要编写新的具体产品类,一定程度上增加了系统的复杂度
- 考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度


#### 3.2.1 简单工厂模式

又叫静态工厂模式，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象。

实际的项目中，我们常常需要根据用户的权限来渲染不同的页面，高级权限的用户所拥有的页面有些是无法被低级权限的用户所查看。

简单工厂的优点在于，你只需要一个正确的参数，就可以获取到你所需要的对象，而无需知道其创建的具体细节。但是在函数内包含了所有对象的创建逻辑（构造函数）和判断逻辑的代码，每增加新的构造函数还需要修改判断逻辑代码。当我们的对象不是上面的3个而是30个或更多时，这个函数会成为一个庞大的超级函数，便得难以维护。

> 注意: 简单工厂只能作用于创建的对象数量较少，对象的创建逻辑不复杂时使用

#### 3.2.2 工厂方法模式 Factory Method

工厂方法模式的本意是`将实际创建对象的工作推迟到子类`中，这样核心类就变成了抽象类。但是在JavaScript中很难像传统面向对象那样去实现创建抽象类。所以在JavaScript中我们只需要参考它的核心思想即可。我们可以将工厂方法看作是一个实例化对象的工厂类。

虽然ES6也没有实现abstract，但是我们可以使用 `new.target` 来模拟出抽象类。`new.target` 指向直接被new执行的构造函数，我们`对new.target进行判断，如果指向了该类则抛出错误来使得该类成为抽象类`。

在简单工厂模式中，我们每添加一个构造函数需要修改两处代码。现在我们使用工厂方法模式改造上面的代码，刚才提到，工厂方法我们只把它看作是一个实例化对象的工厂，它只做实例化对象这一件事情！

#### 3.2.3 抽象工厂模式 Abstract Factory

抽象工厂模式并不直接生成实例， 而是用于对`产品类簇的创建`。

在抽象工厂中，类簇一般用父类定义，并在父类中定义一些抽象方法，再通过抽象工厂让子类继承父类。所以，`抽象工厂其实是实现子类继承父类的方法`。

抽象方法是指声明但不能使用的方法。在其他传统面向对象的语言中常用abstract进行声明，但是在JavaScript中，abstract是属于保留字，但是我们可以通过在类的方法中抛出错误来模拟抽象类。

专业解释：

抽象工厂模式提供一个接口用于创建一系列相关或相互依赖的对象，而无需指定具体类。客户端使用此接口选择所需的产品族中的产品对象。

通俗理解：

设想一个汽车工厂不仅能生产各种类型的车（如轿车、SUV等），还能生产配套的轮胎和内饰。客户只要告诉工厂要哪种类型的车，工厂就会相应地提供整套适合的汽车部件。

### 3.3 原型模式 Prototype pattern

通俗点讲就是`创建一个共享的原型，并通过拷贝这些原型创建新的对象`。用于`创建重复的对象`，这种类型的设计模式属于创建型模式，它提供了一种创建对象的不错选择。

1. Object.create() 方法会使用指定的原型对象及其属性去创建一个新的对象。

2. 自定义实现原型模式

3. 自定义类继承

### 3.4 建造者模式 Builder

将一个复杂的对象分解成多个简单的对象来进行构建，将复杂的构建层与表现层分离，使相同的构建过程可以创建不同的表示模式

简单例子来说：当我们在外面饭店吃饭时，比如点个水煮肉片，这家店可能会辣一点、那家店可能会咸一点、对面那家可能放青菜、隔壁那家可能放菠菜，每家店做出来的都不一样，明明都是水煮肉片却有不同的做法，如果都一样就不会说这家难吃那家好吃了。那再看KFC，我们点个汉堡，所有人不管在哪个城市哪家店，做法、味道都是一样的，为什么呢，因为它用料、时间、温度等等都是严格规定的，我们只需要下订单就行了，这就是一个建造者模式。

> 建造者模式的主要角色如下：

- 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。
- 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。
- 具体建造者（Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。
- 指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。

> 1.使用场景

- 需要生成的对象具有复杂的内部结构时。
- 相同的方法，不同的执行顺序，产生不同的结果。
- 多个部件或零件，都可以装配到一个对象中，但是产生的结果又不相同。

> 2.优点

- 封装性。是客户端不必知道产品内部组成的细节。
- 建造者独立，易扩展。
- 便于控制细节风险。可以对建造过程逐步细化，而不对其他模块产生任何影响。

> 3.缺点

- 产品必须有共同点，范围有限制。
- 如果内部变化复杂，会有很多建造类。

### 3.5 适配器模式 Adapter Pattern

适配器模式是一种结构型设计模式，它允许将一个类的接口转换成客户端期望的另一个接口。适配器模式主要用于使原本由于接口不匹配而无法一起工作的两个类能够协同工作。

适配器模式涉及以下几个关键角色：

- 目标接口（Target Interface）： 客户端所期望的接口，适配器通过实现这个接口，使得客户端可以调用适配器的方法。
- 适配器（Adapter）： 实现目标接口并包装一个或多个被适配者对象，以便将调用转发给被适配者。
- 被适配者（Adaptee）： 需要被适配的类或接口，它定义了客户端不知道的方法，适配器通过调用被适配者的方法来完成适配。
- 客户端（Client）： 使用目标接口的对象，与适配器交互。

适配器模式主要有两种形式：类适配器和对象适配器。

> 优点

- 可以让任何两个没有关联的类一起运行。
- 提高了类的复用。
- 适配对象，适配库，适配数据

> 缺点

- 额外对象的创建，非直接调用，存在一定的开销(且不像代理模式在某些功能点上可实现性能优化)
- 如果没必要使用适配器模式的话，可以考虑重构，如果使用的话，尽量把文档完善

> 场景

- 整合第三方SDK
- 封装旧接口
- 当需要使用一个已经存在的类，而它的接口与你所需要的不匹配时。
- 当你想创建一个可复用的类，该类可以与其他不相关的类或不可预见的类（即接口不一致的类）协同工作时。
- 适配器模式使得不同接口的类能够协同工作，使系统更加灵活，同时能够保持类的独立性和可复用性。

### 3.6 装饰器模式 Decorator Pattern

装饰器模式允许动态地给对象添加新的行为，而不需要修改对象的原始代码。在装饰器模式中，我们定义一个装饰器对象，它包含一个原始对象，并且实现了与原始对象相同的接口。我们可以使用装饰器对象来给原始对象添加新的行为，同时也可以在不改变原始对象的前提下，使用不同的装饰器组合来达到不同的效果。

> 意图: 动态地给一个对象添加额外的职责，同时不改变其结构。装饰器模式提供了一种灵活的替代继承方式来扩展功能。

> 优点
- 可以动态地添加新的行为，而不需要修改原始对象的代码。
- 可以使用多个装饰器组合，从而达到不同的效果。
- 遵循开闭原则，允许在不改变现有代码的情况下扩展系统功能。

> 缺点
- 如果装饰器的数量太多，可能会导致代码复杂度增加，降低代码的可读性和可维护性。
- 如果装饰器的使用不当，可能会导致对象状态的混乱和不一致。

> 适用场景
- 当需要动态地给对象添加新的行为，同时又需要保持原始对象的不变性时。
- 当需要在运行时动态地添加或移除对象的功能时。
- 当需要通过组合不同的装饰器来实现不同的效果时。

> 在装饰者模式中，有几个关键角色
- 组件接口（Component）： 定义了具体组件和装饰者共用的接口，确保它们是可互换的。
- 具体组件（Concrete Component）： 实现了组件接口，是被装饰的原始对象。
- 装饰者（Decorator）： 实现了组件接口并持有一个具体组件的引用，在其上可以添加额外的行为。
- 具体装饰者（Concrete Decorator）： 扩展了装饰者接口，实现了具体的装饰行为。

在TypeScript中装饰器可以修饰4种语句：类,方法,方法参数,属性。

> 执行顺序

1. 有多个参数装饰器时：从最后一个参数依次向前执行
2. 方法和方法参数中参数装饰器先执行。
3. 类装饰器总是最后执行。
4. 方法和属性装饰器，谁在前面谁先执行。因为参数属于方法一部分，所以参数会一直紧紧挨着方法执行。

```js

/**
 * 类装饰器
 * @param path
 * @returns
 */
function Path(path: string) {
  return function (target: Function) {
    !target.prototype.$Meta && (target.prototype.$Meta = {});
    target.prototype.$Meta.baseUrl = path;
  };
}

/**
 * 类成员装饰器
 * @param {*} target 被修饰的类的原型对象
 * @param {*} name 类成员的名字
 * @param {*} descriptor 类成员的描述对象
 * @returns
 */
function readonly(target, name, descriptor) {
  descriptor.writable = false;
  return descriptor;
}

/**
 * 方法装饰器
 * @param url
 * @returns
 */
function GET(url: string) {
  return function (target, methodName: string, descriptor: PropertyDescriptor) {
    !target.$Meta && (target.$Meta = {});
    target.$Meta[methodName] = url;
  };
}

/**
 * 方法参数装饰器
 * @param paramName
 * @returns
 */
function PathParam(paramName: string) {
  return function (target, methodName: string, paramIndex: number) {
    !target.$Meta && (target.$Meta = {});
    target.$Meta[paramIndex] = paramName;
  };
}

/**
 * 属性装饰器
 * @param value
 * @returns
 */
function DefaultValue(value: string) {
  return function (target: any, propertyName: string) {
    target[propertyName] = value;
  };
}
```

### 3.7 代理模式 Proxy Pattern

代理模式（Proxy Pattern）是一种结构型设计模式，其主要目的是通过引入一个代理对象来控制对另一个对象的访问。代理对象充当了客户端和目标对象之间的中介，可以用于实现各种用途，如延迟加载、权限控制、日志记录等。

> 代理模式涉及到以下几个角色：

- 抽象主题（Subject）： 定义了目标对象和代理对象的共同接口，客户端通过该接口访问目标对象。
- 具体主题（Real Subject）： 实现了抽象主题接口，是真正的目标对象，代理对象直接控制对它的访问。
- 代理（Proxy）： 实现了抽象主题接口，保存了对真正目标对象的引用，客户端通过代理访问目标对象。代理对象可以在客户端访问目标对象之前或之后执行一些额外的操作。

> 代理模式可以分为多种类型

- 静态代理（Static Proxy）： 代理对象在编译时就已经确定，代理类和目标类的关系在编译阶段就确定了。静态代理需要为每一个目标类创建一个代理类，导致类的数量增加。
- 动态代理（Dynamic Proxy）： 代理对象在运行时动态生成，代理类不需要预先定义，而是在运行时根据需要创建。Java 中的 java.lang.reflect.Proxy 和 InvocationHandler 接口就是动态代理的经典实现。

### 3.8 外观模式 Facade Pattern

外观模式（Facade Pattern）是一种结构型设计模式，它提供了一个统一的接口，用于访问子系统中的一群接口。外观模式定义了一个高层接口，使得子系统更容易使用。

外观模式的主要目的是简化客户端与复杂系统之间的交互，通过引入一个外观类，隐藏了系统的复杂性，使得客户端只需与外观类交互，而无需直接与子系统中的各个组件打交道。这有助于减少客户端与子系统之间的依赖关系，提高了系统的灵活性和可维护性。

> 外观模式涉及到以下几个角色：

- 外观（Facade）： 提供了一个高层次的接口，该接口使用了子系统中的一群接口，使得子系统更容易使用。
- 子系统（Subsystems）： 由多个类组成，实现了系统的各个功能。外观将客户端请求代理给适当的子系统对象。
- 客户端（Client）： 通过外观接口与子系统交互，而无需直接与子系统的具体实现打交道。

>应用场景
- 维护设计粗糙和难以理解的遗留系统，或者系统非常复杂的时候，可以为这些系统设置外观模块，给外界提供清晰的接口，以后新系统只需与外观交互即可。
- 你写了若干小模块，可以完成某个大功能，但日后常用的是大功能，可以使用外观来提供大功能，因为外界也不需要了解小模块的功能。
- 团队协作时，可以给各自负责的模块建立合适的外观，以简化使用，节约沟通时间。 如果构建多层系统，可以使用外观模式来将系统分层，让外观模块成为每层的入口，简化层间调用，松散层间耦合。

>优点
- 访问者不需要再了解子系统内部模块的功能，而只需和外观交互即可，使得访问者对子系统的使用变得简单，符合最少知识原则，增强了可移植性和可读性；
- 减少了与子系统模块的直接引用，实现了访问者与子系统中模块之间的松耦合，增加了可维护性和可扩展性；
- 通过合理使用外观模式，可以帮助我们更好地划分系统访问层次，比如把需要暴露给外部的功能集中到外观中，这样既方便访问者使用，也很好地隐藏了内部的细节，提升了安全性；

>缺点
- 不符合开闭原则，对修改关闭，对扩展开放，如果外观模块出错，那么只能通过修改的方式来解决问题，因为外观模块是子系统的唯一出口；
- 不需要或不合理的使用外观会让人迷惑，过犹不及；

### 3.9 桥接模式 Bridge Pattern

桥接模式（Bridge Pattern）是一种结构型设计模式，它将抽象部分与实现部分分离，使它们可以独立变化，而不影响彼此。桥接模式主要用于处理具有多层次继承结构的情况，通过将抽象部分和实现部分分开，使得系统更加灵活。

> 在桥接模式中，有两个关键的角色：

- 抽象类（Abstraction）： 定义了抽象部分的接口，并维护一个指向实现部分的引用。
- 实现类（Implementor）： 定义了实现部分的接口，被抽象类引用。
- 具体抽象类（Concrete Abstraction）： 继承自抽象类，实现抽象类定义的接口。
- 具体实现类（Concrete Implementor）： 继承自实现类，实现实现类定义的接口。

> 优点
- 分离了抽象和实现部分，将实现层（DOM 元素事件触发并执行具体修改逻辑）和抽象层（ 元素外观、尺寸部分的修改函数）解耦，有利于分层；
- 提高了可扩展性，多个维度的部件自由组合，避免了类继承带来的强耦合关系，也减少了部件类的数量；
- 使用者不用关心细节的实现，可以方便快捷地进行使用；

> 缺点
- 桥接模式要求两个部件没有耦合关系，否则无法独立地变化，因此要求正确的对系统变化的维度进行识别，使用范围存在局限性；
- 桥接模式的引入增加了系统复杂度；

> 适用场景
- 一个类存在两个以上独立变化的维度，且这些类都要进行拓展。
- 多层次的继承关系导致子类急剧增加
- 抽象化类和具体化类之间想要增加更多的灵活性

### 3.10 组合模式 Composite Pattern

组合模式（Composite Pattern）是一种结构型设计模式，它允许你将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得客户端对单个对象和组合对象的使用具有一致性。

> 在组合模式中，有两种关键角色：
1. 组件（Component）： 定义了树形结构中所有具体对象和组合对象的共同接口。
2. 叶子（Leaf）： 实现了组件接口的叶子对象，它是树中的叶子节点，没有子节点。
3. 合成（Composite）： 实现了组件接口的组合对象，它具有叶子和其他组合对象作为子节点，可以递归地组合成更复杂的树形结构。

> 应用场景
- 优化处理递归或分级数据结构（文件系统 - 目录文件管理）；
- 与其它设计模式联用，如与命令模式联用实现 “宏命令”。

> 优点
- 忽略组合对象和单个对象的差别，对外一致接口使用；
- 解耦调用者与复杂元素之间的联系，处理方式变得简单。

> 缺点
- 树叶对象接口一致，无法区分，只有在运行时方可辨别；
- 包裹对象创建太多，额外增加内存负担。

### 3.11 享元模式 Flyweight Pattern

享元模式（Flyweight Pattern）是一种结构型设计模式，旨在通过共享对象来减少内存和计算开销。该模式适用于系统中存在大量相似对象，它通过共享这些对象的相同部分，减少了实例的数量，从而降低了内存占用和提高了性能。

> 在享元模式中，存在两种类型的状态：

内部状态（Intrinsic State）： 内部状态是对象可共享的部分，它存储在享元对象内部并且不会随环境的改变而改变。对于所有共享对象，内部状态是一致的。
外部状态（Extrinsic State）： 外部状态是对象依赖的、随环境改变而改变的部分。它不可共享，需要在使用享元对象时由客户端传递给享元对象。

享元模式的关键是将对象的状态分为内部状态和外部状态，并尽可能共享内部状态。

> 应用场景
- 对象的大多数状态都可以变为外部状态
- 一个程序中使用了大量的相似对象
- 由于使用了大量对象，造成很大的内存开销
- 剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象

### 3.12 观察者模式 Observer Pattern & 订阅发布模式 Pub-Sub Pattern

#### 3.12.1 观察者模式 Observer Pattern

观察者模式（Observer Pattern）：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。

所谓观察者模式，其实就是为了实现 `松耦合`（Loosely Coupled）。

举个例子，当数据有更新，如 changed 方法被调用，用于更新 state 数据，比如温度、气压等。

这些的问题是，如果向更新更多的信息，比如说湿度，那就要去修改 changed 方法的代码，这就是紧耦合的坏处。

对于观察者模式，我们仅仅维护一个可观察对象即可，即一个 Observable 实例，当有数据变更时，它只需维护一套观察者（Observer）的集合，这些 Observer 实现相同的接口，Subject 只需要指导，通知 Observer 时，需要调用哪个同一方法就好了。

> 观察者模式包含如下角色

- Subject（目标）：知道它的通知对象，事件发生后会通知所有它知道的对象，提供添加删除观察者的接口。
- ConcreteSubject（具体目标）：被观察者具体的实例，存储观察者感兴趣的状态。
- Observer（观察者）：提供通知后的更新事件。
- ConcreteObserver（具体观察者）：被观察者具体的实例，存储观察者感兴趣的状态。

> 优点
- 支持简单的广播通信，自动通知所有已经订阅过的对象
- 目标对象与观察者之间的抽象耦合关系能单独扩展以及重用
- 增加了灵活性
- 观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。

> 缺点
- 过度使用会导致对象与对象之间的联系弱化，会导致程序难以跟踪维护和理解

> 应用场景
- DOM事件
- vue响应式

#### 3.12.2 订阅发布模式 Pub-Sub Pattern

订阅发布模式（Pub-Sub Pattern）属于广义上的观察者模式

发布订阅模式是最常用的一种观察者模式的实现，并且从解耦和重用角度来看，更优于典型的观察者模式。

![订阅发布模式](./img/sjms13.png)

> 完成订阅发布整个流程需要三个角色
- 发布者
- 事件中心
- 订阅者

以事件为例，简单流程如下：

发布者->事件中心<=>订阅者，订阅者需要向事件中心订阅指定的事件 -> 发布者向事件中心发布指定事件内容 -> 事件中心通知订阅者 -> 订阅者收到消息（可能是多个订阅者），到此完成了一次订阅发布的流程。

- 在观察者模式中，观察者需要直接订阅目标事件；在目标发出内容改变的事件后，直接接收事件并作出响应。
- 在发布订阅模式中，发布者和订阅者之间多了一个发布通道；一方面从发布者接收事件，另一方面向订阅者发布事件；订阅者需要从事件通道订阅事件。

> 应用场景
- EventEmitter
- node 的 events

订阅者在订阅事件的时候，只关注事件本身，而不关心谁会发布这个事件；发布者在发布事件的时候，只关注事件本身，而不关心谁订阅了这个事件。

#### 3.12.3 订阅发布模式和观察者模式的区别

> 角色角度来看
- 订阅发布模式需要三种角色，发布者、事件中心和订阅者。而观察者模式需要两种角色，目标和观察者，无事件中心负责通信。

> 从耦合度上来看
- 订阅发布模式是一个事件中心调度模式，订阅者和发布者是没有直接关联的，通过事件中心进行关联，两者是解耦的。而观察者模式中目标和观察者是直接关联的，耦合在一起（有些观念说观察者是解耦，解耦的是业务代码，不是目标和观察者本身）。

> 订阅发布模式优点
- 灵活
- 由于订阅发布模式的发布者和订阅者是解耦的，只要引入订阅发布模式的事件中心，无论在何处都可以发布订阅。同时订阅发布者相互之间不影响。
- 订阅发布模式在使用不当的情况下，容易造成数据流混乱，所以才有了 React 提出的单项数据流思想，就是为了解决数据流混乱的问题。

> 订阅发布模式缺点
- 容易导致代码不好维护
- 灵活是有点，同时也是缺点，使用不当就会造成数据流混乱，导致代码不好维护。
- 性能消耗更大
- 订阅发布模式需要维护事件列队，订阅的事件越多，内存消耗越大。

> 观察者模式优点
- 响应式
- 目标变化就会通知观察者，这是观察者最大的有点，也是因为这个优点，观察者模式在前端才会这么出名。

> 观察者模式缺点
- 不灵活
- 相比订阅发布模式，由于目标和观察者是耦合在一起的，所以观察者模式需要同时引入目标和观察者才能达到响应式的效果。而订阅发布模式只需要引入事件中心，订阅者和发布者可以不再一处。

### 3.13 迭代器模式 Iterator Pattern

提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象的内部表示。

> 迭代器的实现
- 定义迭代器接口: 迭代器模式的核心是定义一个迭代器接口，该接口包含两个方法：next和hasNext。next方法返回序列中的下一个元素，而hasNext方法检查序列是否还有元素。
- 实现迭代器 :要实现一个迭代器，可以创建一个包含内部指针和next方法的对象。next方法返回序列中的下一个元素，并更新内部指针。如果序列中没有更多的元素，则返回空。
- 使用迭代器 :一旦有了迭代器，就可以通过调用next方法和检查hasNext方法来遍历序列。例如，可以遍历数组中的所有元素

> 优点
- 迭代器模式的一个主要优点是它提供了一种灵活的、统一的方式来访问序列中的元素。这意味着可以轻松地在不同的序列上执行相同的操作，从而减少了代码的复杂性。另外，迭代器模式还可以隐藏序列的实现细节，并提供对序列顺序的控制。

> 缺点
- 尽管迭代器模式提供了很多好处，但也存在一些缺点。首先，实现迭代器需要一些额外的代码，这可能会增加应用程序的复杂性。此外，许多现代浏览器都支持迭代器，但是一些旧的浏览器可能不支持此API。

迭代器模式是一种非常有用的模式，尤其是在处理大型数据集时。它提供了一种灵活的、统一的方式来访问序列中的元素。虽然它可能需要一些额外的代码来实现，但是这些成本可以通过减少代码的复杂性和隐藏序列的实现细节来弥补。
