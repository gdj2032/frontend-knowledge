# 设计模式

## 1.目的

设计模式是为了更好的代码复用、可读、可靠、可维护。

## 2.原则

1、单一职责原则（SRP）[Single Responsibility Principle]

一个对象（方法）只做一件事情

2、里氏替换原则

子类可以扩展父类的功能，但不能改变父类原有的功能

3、依赖倒置原则

高层模块不应该依赖低层模块，二者都应该依赖其抽象。抽象不应该依赖细节，细节应该依赖抽象。(就是将公共的业务逻辑抽象出来)

4、接口隔离原则

在一个类中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越少，同时也有利于降低成本

5、合成复用原则

尽量使用对象组合/聚合，而不是继承关系达到软件复用的目的

6、最少知识原则

减少对象（方法、系统、模块等）之间的联系

## 3.类型

  单例模式（Singleton Pattern）：确保一个类只有一个实例，并提供一个全局访问点。

  工厂模式（Factory Pattern）：通过一个工厂函数来创建对象，而不是通过直接调用构造函数。这样可以隐藏创建对象的细节，并将其与具体的实现分离开来。

  观察者模式（Observer Pattern）：定义了一种一对多的依赖关系，当一个对象状态发生改变时，所有依赖它的对象都会自动更新。

  发布-订阅模式（Publish-Subscribe Pattern）：与观察者模式类似，但是将发布者和订阅者解耦，使得它们可以独立地进行修改。

  命令模式（Command Pattern）：将请求封装成一个对象，从而使得请求的调用者和请求的接收者之间解耦。可以用于实现撤销、重做等功能。

  装饰器模式（Decorator Pattern）：给对象动态地添加新的功能，同时又不改变其原有的结构和功能。

  适配器模式（Adapter Pattern）：将一个类的接口转换成客户端所期望的另外一个接口，从而使得原本不兼容的类可以一起工作。

  策略模式（Strategy Pattern）：定义一系列算法，将每个算法都封装起来，并且使它们可以互换。策略模式使得算法可以独立于使用它的客户端而变化。

### 3.1 单例模式（Singleton）

专业解释：

单例模式是一种确保在任何情况下一个类仅有一个实例，并提供全局访问点的设计模式。它主要用于控制对全局唯一资源的访问。

通俗理解：

就好比一座城市里只有一座供水站，不论你需要从哪里取水，都只能通过这个供水站来获取，而且全市人民共用的是同一座供水站。

> 优点：

节约系统资源，对于那些需要频繁创建和销毁的对象，单例模式可以提高系统性能。

提供了全局访问点，对象间通信更简单。

> 缺点：

不适用于多线程环境，可能会引起线程安全问题。

单例对象的状态，对于依赖它的对象可能不易处理。

单例模式在系统中引入全局状态，增加了测试的复杂性。

### 3.2 抽象工厂模式（Abstract Factory）

专业解释：

抽象工厂模式提供一个接口用于创建一系列相关或相互依赖的对象，而无需指定具体类。客户端使用此接口选择所需的产品族中的产品对象。

通俗理解：

设想一个汽车工厂不仅能生产各种类型的车（如轿车、SUV等），还能生产配套的轮胎和内饰。客户只要告诉工厂要哪种类型的车，工厂就会相应地提供整套适合的汽车部件。



<!--
### 3.2 工厂模式（Factory Pattern）

定义: 是一种创建对象的设计模式，它通过一个工厂函数来创建对象，而不是通过直接调用构造函数。工厂模式可以隐藏对象创建的具体细节，使得客户端代码与具体的实现分离开来。

简单工厂模式：
```js
   function createProduct(type) {
     if (type === 'A') {
       return new ProductA();
     } else if (type === 'B') {
       return new ProductB();
     }
     // ...
   }

   const productA = createProduct('A');
   const productB = createProduct('B');
```
构造函数工厂模式：
```js
   function ProductFactory(type) {
     if (type === 'A') {
       return new ProductA();
     } else if (type === 'B') {
       return new ProductB();
     }
     // ...
   }

   const productA = new ProductFactory('A');
   const productB = new ProductFactory('B');
```
原型工厂模式：
```js
   function ProductFactory() {}

   ProductFactory.prototype.createProduct = function(type) {
     if (type === 'A') {
       return new ProductA();
     } else if (type === 'B') {
       return new ProductB();
     }
     // ...
   };

   const factory = new ProductFactory();
   const productA = factory.createProduct('A');
   const productB = factory.createProduct('B');
```
这些都是基本的工厂模式实现方式，根据具体需求可以灵活地选择使用哪种方式。工厂模式可以帮助我们创建对象，封装对象的创建过程，并提供一个统一的接口，使得客户端代码更加简洁和可维护。

### 3.3 观察者模式
观察者模式（Observer Pattern）是一种行为设计模式，它定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都会自动更新。观察者模式也被称为发布-订阅模式（Publish-Subscribe Pattern）。

1.自定义观察者：
```js
   function ObserverList() {
     this.observers = [];
   }

   ObserverList.prototype.add = function(obj) {
     return this.observers.push(obj);
   };

   ObserverList.prototype.count = function() {
     return this.observers.length;
   };

   ObserverList.prototype.get = function(index) {
     if (index > -1 && index < this.observers.length) {
       return this.observers[index];
     }
   };

   ObserverList.prototype.indexOf = function(obj, startIndex) {
     let i = startIndex;

     while (i < this.observers.length) {
       if (this.observers[i] === obj) {
         return i;
       }
       i++;
     }

     return -1;
   };

   ObserverList.prototype.removeAt = function(index) {
     this.observers.splice(index, 1);
   };

   function Subject() {
     this.observers = new ObserverList();
   }

   Subject.prototype.addObserver = function(observer) {
     this.observers.add(observer);
   };

   Subject.prototype.removeObserver = function(observer) {
     this.observers.removeAt(this.observers.indexOf(observer, 0));
   };

   Subject.prototype.notify = function(context) {
     const observerCount = this.observers.count();
     for (let i = 0; i < observerCount; i++) {
       this.observers.get(i).update(context);
     }
   };
```

2.使用内置的 EventEmitter：
```js
   const EventEmitter = require('events');
   const emitter = new EventEmitter();

   emitter.on('event', function(arg) {
     console.log(`event: ${arg}`);
   });

   emitter.emit('event', 'Hello World!');
```
以上是两种常见的实现方式，可以根据具体需求来选择使用哪种方式。观察者模式可以帮助我们实现松耦合的对象间通信，使得对象之间更易于扩展和维护。在 JavaScript 中，观察者模式也是一个非常常用的模式，例如在 React 中的组件生命周期、Redux 中的 Store 状态更新等都用到了观察者模式。

### 3.4 发布-订阅模式
发布-订阅模式（Publish-Subscribe Pattern）是一种行为设计模式，它定义了一种对象间的一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都会自动更新。和观察者模式类似，但有不同之处，观察者模式中观察者订阅主题，而发布-订阅模式中订阅者订阅主题。

1.自定义事件：
```js
   function Event() {
     this.handlers = {};
   }

   Event.prototype.on = function(type, handler) {
     if (!this.handlers[type]) {
       this.handlers[type] = [];
     }
     this.handlers[type].push(handler);
   };

   Event.prototype.emit = function(type, data) {
     if (this.handlers[type]) {
       this.handlers[type].forEach(function(handler) {
         handler(data);
       });
     }
   };
```

2.使用内置的 EventEmitter：
```js
   const EventEmitter = require('events');
   const emitter = new EventEmitter();

   emitter.on('event', function(arg) {
     console.log(`event: ${arg}`);
   });

   emitter.emit('event', 'Hello World!');
```

### 3.5 命令模式
JavaScript中的命令模式是一种设计模式，它将请求封装成单独的对象，使得可以将请求的发送者和接收者解耦。在命令模式中，命令被视为一个对象，该对象将方法调用及其参数封装起来。通过这样的方式，可以将方法调用及其参数传递给别的代码，而不必暴露调用的具体实现。

```js
// 定义一个命令对象
var Command = function (execute, undo, value) {
  this.execute = execute;
  this.undo = undo;
  this.value = value;
};

// 定义命令对象的执行方法
Command.prototype.execute = function () {
  throw new Error("execute method must be overwritten");
};

// 定义命令对象的撤销方法
Command.prototype.undo = function () {
  throw new Error("undo method must be overwritten");
};

// 定义一个接收者对象
var Receiver = function () {
  this.value = 0;
};

// 定义接收者对象的方法
Receiver.prototype.add = function (value) {
  this.value += value;
};

Receiver.prototype.sub = function (value) {
  this.value -= value;
};

// 定义一个命令对象的实现
var AddCommand = function (receiver, value) {
  this.receiver = receiver;
  this.value = value;
};

AddCommand.prototype = new Command();

AddCommand.prototype.execute = function () {
  this.receiver.add(this.value);
};

AddCommand.prototype.undo = function () {
  this.receiver.sub(this.value);
};

// 定义一个命令队列对象
var CommandQueue = function () {
  this.commands = [];
  this.position = -1;
};

// 定义命令队列对象的方法
CommandQueue.prototype.addCommand = function (command) {
  this.commands.push(command);
  this.position++;
};

CommandQueue.prototype.undo = function () {
  if (this.position >= 0) {
    var command = this.commands[this.position];
    command.undo();
    this.position--;
  }
};

CommandQueue.prototype.redo = function () {
  if (this.position < this.commands.length - 1) {
    this.position++;
    var command = this.commands[this.position];
    command.execute();
  }
};

// 使用上述对象实现一个简单的计算器
var receiver = new Receiver();
var addCommand = new AddCommand(receiver, 10);
var subCommand = new AddCommand(receiver, 5);

var commandQueue = new CommandQueue();
commandQueue.addCommand(addCommand);
commandQueue.addCommand(subCommand);

console.log(receiver.value); // 输出：0

commandQueue.execute();
console.log(receiver.value); // 输出：10

commandQueue.undo();
console.log(receiver.value); // 输出：0

commandQueue.redo();
console.log(receiver.value); // 输出：10
```

在上面的示例中，我们定义了一个Command对象，它封装了执行和撤销命令的方法，并且具有一个value属性。我们还定义了一个Receiver对象，它包含了一些方法，用于执行真正的操作。接下来，我们定义了一个AddCommand对象，它继承自Command对象，并且实现了execute和undo方法。最后，我们定义了一个CommandQueue对象，它维护了一个命令的队列，并且包含了undo和redo方法。

### 3.6 装饰器模式
JavaScript中的装饰器模式是一种结构型设计模式，它允许我们通过将对象包装在装饰器对象中来动态地添加新的行为或功能，而无需修改原始对象的结构。装饰器模式通过使用组合而非继承的方式来实现功能的扩展。

```js
// 原始对象
class Car {
  drive() {
    console.log('Driving the car');
  }
}

// 装饰器类
class CarDecorator {
  constructor(car) {
    this.car = car;
  }

  drive() {
    this.car.drive(); // 调用原始对象的方法
    this.addExtraFunctionality(); // 添加额外功能
  }

  addExtraFunctionality() {
    console.log('Adding extra functionality');
  }
}

// 创建原始对象
const myCar = new Car();

// 使用装饰器包装原始对象
const decoratedCar = new CarDecorator(myCar);

// 调用装饰后的对象
decoratedCar.drive();
```
在上述示例中，我们有一个原始对象Car，它具有一个drive方法。然后，我们定义了一个装饰器类CarDecorator，它接收一个Car对象作为构造函数的参数，并在drive方法中调用原始对象的drive方法，并添加了额外的功能。最后，我们创建一个原始对象myCar和装饰后的对象decoratedCar，并调用decoratedCar的drive方法。

通过使用装饰器模式，我们可以动态地为原始对象添加新的功能，而无需修改原始对象的代码。这使得我们可以轻松地扩展现有的对象，并且使得代码更加灵活和可维护。另外，我们还可以使用多个装饰器对象来为原始对象添加不同的功能，从而实现更复杂的装饰效果。

### 3.7 适配器模式
JavaScript中的适配器模式是一种结构型设计模式，它允许我们将一个类的接口转换成客户端所期望的另一个接口。适配器模式的目的是使不兼容的接口能够协同工作。

```js
// 目标接口
class Target {
  request() {
    console.log('Target: Requesting');
  }
}

// 适配者类
class Adaptee {
  specificRequest() {
    console.log('Adaptee: Specific Requesting');
  }
}

// 适配器类
class Adapter extends Target {
  constructor(adaptee) {
    super();
    this.adaptee = adaptee;
  }

  request() {
    console.log('Adapter: Converting the request');
    this.adaptee.specificRequest(); // 调用适配者的方法
  }
}

// 创建适配者对象
const adaptee = new Adaptee();

// 创建适配器对象
const adapter = new Adapter(adaptee);

// 调用适配器的方法
adapter.request();
```
在上述示例中，我们有一个目标接口Target，它定义了一个request方法。然后，我们有一个适配者类Adaptee，它具有一个specificRequest方法。接下来，我们定义了一个适配器类Adapter，它继承自目标接口Target，并接收一个适配者对象作为构造函数的参数。在适配器类中，我们实现了request方法，并在方法中转换调用适配者对象的specificRequest方法。最后，我们创建了适配者对象adaptee和适配器对象adapter，并调用适配器的request方法。

通过使用适配器模式，我们可以将不兼容的接口转换成可兼容的接口，使得客户端能够使用统一的接口与各种不同的对象进行交互。适配器模式提供了一种解决接口不一致问题的灵活方式，同时也使得代码更具可扩展性和可维护性。 -->
