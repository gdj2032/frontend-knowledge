# 面向对象 oop

## 1.对象

本质上是一种特殊的数据结构

class 类 对象的设计图/模板

## 2.this

this就是一个变量,获取当前对象.

解决变量名称冲突的问题.

## 3.构造器

创建对象时,对象会去调用构造器,实现初始化赋值

```java
public class Person {
  // 构造器
  public Person() {}
}
```

## 4.封装

用类设计对象处理某一个事物的数据时,应该把要处理的数据,以及处理这些数据的方法,设计到一个对象中去

规范: 合理隐藏 合理暴露

## 5.JavaBean 实体类

是一种特殊形式的类

1.类的成员变量要私有,对外提供get,set方法.
2.类中必须要有一个公共的无参构造器

## 6.static

静态, 修饰成员变量和成员方法

### 6.1 类变量,实例变量

变量按照有无static分为:
- 类变量
    有static修饰,属于类,在计算机内只有1份,会被类的全部对象共享

- 实例变量(对象的变量)
    无static修饰,属于每个对象的

```java
public class Person {
  // 类变量
  static String name;
  // 实例变量
  int age;
}
```

#### 6.1.1 访问方式
类名.类变量(优先) / 对象.类变量

#### 6.1.2 类变量的应用场景

1. 如果某个数据只需要1份,且希望能够被共享(访问,修改),则可以将该数据定义为类变量.
>例如: 系统启动后,需要记住创建了多少个用户对象.

### 6.2 类方法,实例方法

方法按照有无static分为:
- 类方法(静态方法)
    有static修饰,属于类,在计算机内只有1份,会被类的全部对象共享

- 实例方法(对象的方法)
    无static修饰,属于每个对象的

#### 6.2.1 访问方式
类名.类方法(优先) / 对象.类方法

#### 6.2.2 应用场景

工具类

提高代码复用,代码方便,提高开发效率

>为什么工具类中的方法要用类方法,而不使用实例方法?

实例方法需要创建对象,此时对象只是为了调用方法,对象占内存,这样会浪费内存

类方法,直接调用 类名.类方法 即可,调用方便,节省内存

`注意`

工具类没有创建对象的需求,可以将工具类的构造器私有化,这样就创建不了实例对象了

#### 6.2.3 main方法的执行?

```java

public class Test {
    public static void main(String[] args) {
    }
}
```

main方法是类方法,在执行 java Test 时,jvm会自动转换成 java Test.main()

main方法的形参,即 java Test 1 2 3, args为 [1,2,3]

#### 6.2.4 类方法,实例方法注意事项

1. 类方法中可以直接访问类的成员,不能直接访问实例成员
2. 实例方法中,类的成员和实例成员都能访问
3. 实例方法中可以出现this关键字,而类方法中没有this关键字

### 6.3 代码块

是类的5大组成之一(成员变量,构造器,方法,代码块,内部类)

1. 静态代码块

    格式 static {}
    特点 类加载时自动执行,由于类只会加载一次,所以静态代码块也只会执行一次
    作用 完成类的初始化, 例: 对类变量的初始化赋值
2. 实例代码块

    格式 {}
    特点 每次创建对象时,执行实例代码块,并在构造器前执行
    作用 和构造器一样,都是用来完成对象的初始化,例: 对实例变量的初始化赋值

```java
// Person.java
public class Person {
    static int num = 100;
    int age;
    int sex;
    static {
        System.out.println("静态代码块执行~");
        num = 101;
    }
    {
        System.out.println("实例代码块执行~");
        age = 12;
        sex = 13;
    }
}

// Test.java
public class Test {
    public static void main(String[] args) {
        System.out.println(Person.num);
        System.out.println(Person.num);
        System.out.println(Person.num);
        Person p1 = new Person();
        System.out.println(p1.age);
    }
}

/**
 * 输出:
 * 静态代码块执行~
 * 101
 * 101
 * 101
 * 实例代码块执行~
 * 12
 */
```

### 6.4 单例模式

见[11.设计模式.md](./11.设计模式.md)

## 7. 继承 extends

```java
public class B extends A {}
```

A类称为父类(基类/超类),B类称为子类(派生类)

子类能继承父类的非私有成员(变量和方法)

在子类中访问其他成员变量/方法,按照`就近原则`访问.

子类和父类命名冲突,并且需要访问父类的成员时,使用`super`关键字

```java
public class A extends B {
    int a;
    private int b;

    void print() {
        System.out.println(a);
        System.out.println(this.a);
        System.out.println(super.a);
    }
}
```

### 7.1 好处

减少重复代码的编写

>注意：

（1）protected不能修饰类。

（2）priavte可以修饰类，但是该类必须是一个内部类。

在定义类时，推荐访问控制级别从严处理：

（1） 如果不允许外部直接通过 new 创建对象，构造方法必须是 private。

（2）工具类不允许有 public 或 default 构造方法。

（3）类非 static 成员变量并且与子类共享，必须是 protected。

（4）类非static成员变量并且仅在本类使用，必须是private。

（5）类 static 成员变量如果仅在本类使用，必须是 private。

（6）若是 static 成员变量，必须考虑是否为 final。

（7）类成员方法只供类内部调用，必须是 private。

（8）类成员方法只对继承类公开，那么限制为 protected。

### 7.2 单继承

java中类是单继承的,不支持多继承,但是支持多层继承

## 8.多态

多态是在继承/实现情况下的一种现象, 表现为`对象多态, 行为多态`

编译看左边,运行看右边

```java
public class Test {
    public static void main(String[] args) {
        Person p1 = new Student();
        p1.print();
        System.out.println(p1.a);
        Person p2 = new Teacher();
        p2.print();
        // p2.test();
    }
}
```

### 8.1 前提

有继承/实现关系,存在父类引用子类对象,存在方法重写

多态是对象,行为的多态, java中的属性(成员变量)不谈多态

### 8.2 好处

在多态形式下,右边是解耦合的,更便于扩展和维护

### 8.3 问题

多态下不能使用子类特有的功能

### 8.4 类型转换

- 自动类型转换: 父类 变量名 = new 子类() 例: Person p = new Student();
- 强制类型转换: 子类 变量名 = (子类)父类变量名 例 Student s = (Student)p;

>注意
1. 存在继承/实现关系就可以在编译阶段进行强制类型转换,编译阶段不会报错
2. 运行时,如果发现对象的真实类型与强转后的类型不同,就会报类型转换异常的错误(ClassCastException)

>强转建议
1. 使用`instanceof`关键字,判断当前对象的真实类型
```java
p instanceof Student;
```

## 9.final

最终的意思,修饰类,方法,变量

1. 修饰类: 称为最终类,不能被继承
2. 修饰方法: 称为最终方法,不能被重写
3. 修饰变量: 该变量只能被赋值一次

```java
// final
public class Test {
    // 常量 public static final
    public static final String NAME = "ggg";
    // private final String name = "ggg"; 无意义,仅了解
    public static void main(String[] args) {
        D d = new D();
        d.test();

        final int a;
        a = 11;
        // a = 12; // 第二次赋值,报错

        // NAME = "222"; // 第二次赋值,报错

        // Test t = new Test();
        // t.name = "1";  // 第二次赋值,报错

        // final修饰`引用类型`的变量,变量存储的`地址`不能被改变,但是地址所指向的对象的内容是可变的
        final int[] i = {1, 2, 3};
        // i = null; 地址不可变
        i[0] = 10; // 值可变
    }

    public static void buy(final double num) {
        // 不能再次赋值,被保护了
        // num = 0.1;
    }
}
class A {
    public final void test() {}
}
final class B { }
class C extends A { }
//class D extends B {} 不能继承final类
class D extends A {
// 不能重写final方法
//    @Override
//    public void test(String name) {
//        System.out.println(1);
//    }
}
```

>注意
1. final修饰`基本类型`的变量,变量存储的`数据`不能被改变
2. final修饰`引用类型`的变量,变量存储的`地址`不能被改变,但是地址所指向的对象的内容是可变的

## 10. 常量

使用了 `static final` 修饰的成员变量就是常量

记录系统的配置信息

使的代码的可读性,可维护性更好

程序编译后,常量会被`宏替换`, .class内的常量字段被替换成字符串

## 11. 抽象 abstract

关键词 abstract, 修饰类,成员方法

1. 抽象类中不一定有抽象方法,有抽象方法的类一定是抽象类
2. 类该有的成员,抽象类都有
3. 抽象类的主要特点: `抽象类不能创建对象,仅作为一种特殊的父类,让子类继承并实现`
4. 一个类继承抽象类,必须重写完抽象类的全部抽象方法,否则这个类也必定定义成抽象类

```java
// 抽象类
abstract class A {
    // 抽象方法, 只有方法名, 没有方法体
    public abstract void run();

    String name;

    public A() {
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

class B extends A {
    @Override
    public void run() {
        System.out.println("b run");
    }
}
```

### 11.1 抽象类的好处

父类知道每个子类都要做某个行为,但每个子类要做的情况不一样,父类就定义成抽象类,交给子类去重写实现,这样写是为了更好的支持多态.
